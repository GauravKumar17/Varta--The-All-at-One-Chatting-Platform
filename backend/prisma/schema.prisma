
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String?   @unique
  otp           String?
  otpExpiry     DateTime?
  username      String?
  phoneNumber   String?   @unique
  phoneSuffix   String?
  profilePic    String?
  isVerified    Boolean?  @default(false)
  isOnline      Boolean?  @default(false)
  lastSeen      DateTime?
  about         String?
  agreedToTerms Boolean?  @default(false)

  participantsIN   ConversationParticipants[]
  messagesSent     Messages[]                 @relation("userMessagesSent")
  messagesReceived Messages[]                 @relation("userMessagesReceived")
  statuses         userStatus[]               @relation("userStatuses")
  statusViews      userStatusView[]           @relation("userStatusViews")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  MessageReaction MessageReaction[]
  
}

model Conversations {
  id            Int       @id @default(autoincrement())
  isGroup       Boolean   @default(false)
  groupName     String?
  groupPic      String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessage   Messages? @relation("lastMessage", fields: [lastMessageId], references: [id])
  lastMessageId Int?      @unique

  participants ConversationParticipants[]
  userMessages Messages[]                 @relation("userMessagesInConversation")
}

model ConversationParticipants {
  id             Int       @id @default(autoincrement())
  conversationId Int
  userId         Int
  unreadCount    Int       @default(0)
  joinedAt       DateTime  @default(now())
  leftAt         DateTime?

  conversation Conversations @relation(fields: [conversationId], references: [id])
  user         User          @relation(fields: [userId], references: [id])
}

model Messages {
  id             Int               @id @default(autoincrement())
  conversation   Conversations     @relation("userMessagesInConversation", fields: [conversationId], references: [id])
  conversationId Int
  sender         User              @relation("userMessagesSent", fields: [senderId], references: [id])
  senderId       Int
  receiver       User              @relation("userMessagesReceived", fields: [receiverId], references: [id])
  receiverId     Int
  content        String
  mediaUrl       String?
  contentType    ContentType
  reactions      MessageReaction[]
  MessageStatus  MessageStatus     @default(SENT)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  lastMessage    Conversations?    @relation("lastMessage")
}

model MessageReaction {
  id        Int      @id @default(autoincrement())
  message   Messages @relation(fields: [messageId], references: [id])
  messageId Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  emoji     String
  createdAt DateTime @default(now())
}

enum ContentType {
  TEXT
  IMAGE
  VIDEO
  DOCUMENT
  AUDIO
  LOCATION
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

model userStatus {
  id          Int          @id @default(autoincrement())
  user        User         @relation("userStatuses", fields: [userId], references: [id])
  userId      Int
  content     String?
  mediaUrl    String?
  contentType ContentType?

  createdAt DateTime @default(now())
  expiresAt DateTime

  views      userStatusView[]
  
  @@index([userId])
  // speeds up lookups for all views by a viewer
  // Without the index, the DB has to scan the entire table to find matches.
  // With the index, it can jump directly to relevant records.

}

model userStatusView {
  id         Int        @id @default(autoincrement())
  status     userStatus @relation(fields: [statusId], references: [id])
  statusId   Int
  viewer     User       @relation("userStatusViews", fields:[viewerId], references: [id])
  viewerId   Int
  viewedAt   DateTime   @default(now())

  @@unique([statusId, viewerId])


}
